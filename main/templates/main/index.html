{% extends "main/base.html" %}
{% load static crispy_forms_tags %}

{% block title %}VDV to Apple Wallet{% endblock title %}

{% block content %}
    <div class="govuk-width-container">
    <h1 class="govuk-heading-xl">VDV/UIC to Apple Wallet Pass</h1>
    <p class="govuk-body-l">
        Turn your public transport ticket into an Apple Wallet pass.
    </p>
    <p class="govuk-body">
        Both VDV and UIC tickets are supported. UIC tickets are usually issued by Deutsche Bahn and other long-distance
        operators, while VDV tickets are issued by German local transport operators.
        UIC tickets may not work as reliably as VDV tickets - they're a lot more complicated.
    </p>
    <p class="govuk-body">
        If you want your tickets to automatically update when they are renewed you can create an account and add the
        subscription. Currently, DB and SaarVV are supported.
    </p>
    <p class="govuk-body">
        These passes should be able to be imported into Google Wallet as well, but updates won't work.
    </p>

    {% if error %}
        <div class="govuk-error-summary" data-module="govuk-error-summary">
            <div role="alert">
                <h2 class="govuk-error-summary__title">{{ error.title }}</h2>
                <div class="govuk-error-summary__body">
                    <p class="govuk-body">{{ error.message }}</p>
                    {% if error.exception %}
                        <details class="govuk-details">
                            <summary class="govuk-details__summary">
                                <span class="govuk-details__summary-text">Full exception</span>
                            </summary>
                            <div class="govuk-details__text">
                                <pre style="overflow-x: auto;font-size: 1rem;">{{ error.exception }}</pre>
                            </div>
                        </details>
                    {% endif %}
                    {% if error.ticket_contents %}
                        <p class="govuk-body-s">
                            Ticket contents; please send this when asking for support:<br/>
                            <code style="line-break: anywhere;">{{ error.ticket_contents }}</code>
                        </p>
                    {% endif %}
                </div>
            </div>
        </div>
    {% endif %}

    <noscript>
        <div class="govuk-error-summary" data-module="govuk-error-summary" id="error-banner">
            <div role="alert">
                <h2 class="govuk-error-summary__title">
                    JavaScript is required to scan tickets
                </h2>
                <div class="govuk-error-summary__body">
                    <p class="govuk-body">
                        JavaScript is required to scan tickets in your browser.
                        You can still upload a picture of your ticket to have it processed server-side.
                    </p>
                </div>
            </div>
        </div>
    </noscript>

    <button id="scan-button" class="govuk-button govuk-button--start" disabled>
        Scan your ticket
        <svg class="govuk-button__start-icon" xmlns="http://www.w3.org/2000/svg" width="17.5" height="19"
             viewBox="0 0 33 40" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M0 0h13l20 20-20 20H0l20-20z"></path>
        </svg>
    </button>

    <div id="video-container" style="display: none;">
        <video id="video" width="100%" height="300" style="border: 1px solid gray"></video>
    </div>

    <form action="" method="post" style="display: none" id="scan-form">
        {% csrf_token %}
        <input type="hidden" name="type" value="scan">
        <input type="hidden" name="ticket_hex" id="data">
    </form>

    <p class="govuk-body">
        If you're having trouble scanning your ticket uploading a picture/screenshot of your ticket usually works better.
        The decoder on the server is better than the one in your browser.
    </p>

    <h2 class="govuk-heading-l">Upload a picture or a PDF instead</h2>
    {% crispy image_form %}

    <hr class="govuk-section-break govuk-section-break--m govuk-section-break--visible">

    <h3 class="govuk-heading-m">Not working?</h3>
    <p class="govuk-body">
        Get in touch with a picture of your ticket and I'll see what I can do.
    </p>
    <ul class="govuk-list govuk-inset-text">
        <li>Fedi: <a href="https://glauca.space/@q" class="govuk-link">@q@glauca.space</a></li>
        <li>Email: <a href="mailto:q@magicalcodewit.ch" class="govuk-link">q@magicalcodewit.ch</a></li>
    </ul>
    <h3 class="govuk-heading-m">Privacy</h3>
    <p class="govuk-body">
        Your ticket barcode will be stored to allow automatic updates to subscription tickets.
        Tickets commonly include your name and date of birth - this information is not processed except to
        generate the pass. Ticket data may be inspected by a human if you ask for help.
    </p>

    <hr class="govuk-section-break govuk-section-break--m govuk-section-break--visible">

    <h3 class="govuk-heading-m">API</h3>
    <p class="govuk-body">
        You can send scanned Aztec barcode contents to this service's API and retrieve PKPass files from it.
    </p>

    <h4 class="govuk-heading-s"><code>POST /api/upload</code></h4>
    <pre><code>Content-Type: application/json

{
    "barcode_data": "&lt;base64 encoded aztec contents>"
}

---

200 OK
Content-Type: application/json

{
    "ticket_id": "EXAMPLE_ID",
    "access_token": "EXAMPLE_TOKEN"
}

---

422 Unprocessable Entity
Content-Type: application/json

{
    "title": "Invalid barcode",
    "message": "This doesn't look like a valid ticket"
}</code></pre>

    <h4 class="govuk-heading-s"><code>GET /api/apple/v1/passes/pass.ch.magicalcodewit.vdv.ticket/EXAMPLE_ID</code></h4>
    <pre><code>Authorization: ApplePass EXAMPLE_TOKEN

---

200 OK
Content-Type: application/vnd.apple.pkpass
Content-Disposition: attachment; filename="EXAMPLE_ID.pkpass"

Pass Contents</code></pre>
    </div>

    <script>
        function ready() {
            const codeReader = new ZXing.BrowserAztecCodeReader();

            const scanButton = document.getElementById("scan-button");
            const videoContainer = document.getElementById("video-container");
            const scanForm = document.getElementById("scan-form");
            const dataInput = document.getElementById("data");

            let videoDeviceId = null;

            codeReader.listVideoInputDevices()
                .then((videoInputDevices) => {
                    console.log("Detected " + videoInputDevices.length + " video sources");
                    if (videoInputDevices.length >= 1) {
                        videoDeviceId = videoInputDevices[0].deviceId;
                        scanButton.disabled = false;
                    }
                });

            scanButton.addEventListener('click', () => {
                codeReader.decodeFromVideoDevice(videoDeviceId, 'video', (result) => {
                    if (result) {
                        console.log(result);
                        codeReader.stopContinuousDecode();
                        videoContainer.style.display = "none";
                        const rawBytes = getEncodedData(result)
                        const hexOctets = new Array(rawBytes.length * 2);
                        for (let i = 0; i < rawBytes.length; ++i)
                            hexOctets.push(("0" + rawBytes[i].toString(16)).slice(-2));
                        dataInput.value = hexOctets.join("");
                        console.log(dataInput.value);
                        scanForm.submit();
                    }
                })
                videoContainer.style.display = "block";
            });
        }

        window.addEventListener('load', ready);

        UPPER = 0;
        LOWER = 1;
        MIXED = 2;
        DIGIT = 3;
        PUNCT = 4;
        BINARY = 5;

        function getEncodedData(result) {
            let correctedBits = [];
            let endIndex = result.getNumBits();
            for (let i = 0; i < endIndex; i++) {
                let byte = result.rawBytes[Math.floor(i / 8)];
                correctedBits.push((byte >> (7 - (i % 8)) & 1) === 1);
            }
            return getEncodedDataBits(correctedBits)
        }

        function getEncodedDataBits(correctedBits) {
            let latchTable = UPPER;
            let shiftTable = UPPER;
            let output = [];
            let index = 0;
            let endIndex = correctedBits.length;
            while (index < endIndex) {
                if (shiftTable === BINARY) {
                    if (endIndex - index < 5) {
                        break;
                    }
                    let length = ZXing.AztecDecoder.readCode(correctedBits, index, 5);
                    index += 5;
                    if (length === 0) {
                        if (endIndex - index < 11) {
                            break;
                        }
                        length = ZXing.AztecDecoder.readCode(correctedBits, index, 11) + 31;
                        index += 11;
                    }
                    for (let charCount = 0; charCount < length; charCount++) {
                        if (endIndex - index < 8) {
                            index = endIndex;
                            break;
                        }
                        const code = ZXing.AztecDecoder.readCode(correctedBits, index, 8);
                        output.push(code);
                        index += 8;
                    }
                    shiftTable = latchTable;
                } else {
                    let size = shiftTable === DIGIT ? 4 : 5;
                    if (endIndex - index < size) {
                        break;
                    }
                    let code = ZXing.AztecDecoder.readCode(correctedBits, index, size);
                    index += size;
                    let str = ZXing.AztecDecoder.getCharacter(shiftTable, code);
                    if (str.startsWith('CTRL_')) {
                        latchTable = shiftTable;
                        shiftTable = ZXing.AztecDecoder.getTable(str.charAt(5));
                        if (str.charAt(6) === 'L') {
                            latchTable = shiftTable;
                        }
                    } else {
                        output.push(str.charCodeAt(0));
                        shiftTable = latchTable;
                    }
                }
            }
            return output;
        }
    </script>
{% endblock content %}